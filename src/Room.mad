import IO from "IO"
import {reduce, append, find, range} from "List"
import {Just, Nothing} from "Maybe"
import {floatToInteger, integerToFloat} from "Number"

import type {
   RecordSeededConfig
} from "@/Config"

import type {Unusual} from "@/Unusual"
import {makeTwister} from "@/Unusual"
import {bound, min, max, abs} from "@/Math"

import type {BoundingBox, Position} from "@/Tile"
import {toString} from "@/String"

export type Room pos w h data
  = Room(pos, w, h, data)

export alias StandardRoom data = Room Position Integer Integer data

export alias DungeonRooms r = List (StandardRoom r)


getBoundingBox :: StandardRoom a -> BoundingBox
export getBoundingBox = (
  where {
    Room(pos, w, h, data) => (
      where (pos) {
        #[x, y] => ({
          top: y,
          bottom: y + h - 1 ,
          left: x,
          right: x + w - 1
        })
      }
    )
  }
)

roomContainsPosition :: StandardRoom a -> Position -> Boolean
export roomContainsPosition = (room, pos) => (
  where (pos) {
    #[x, y] => pipe(
      getBoundingBox,
      (bb) => !(
        x < bb.left   ||
        x > bb.right  ||
        y < bb.top    ||
        y > bb.bottom
      )
    )(room)
  }
)

roomOverlapsRoom :: StandardRoom a -> StandardRoom b -> Boolean
export roomOverlapsRoom = (a, b) => {
  m = getBoundingBox(a)
  n = getBoundingBox(b)
  return !(
    m.left   > n.right  ||
    m.right  < n.left   ||
    m.top    > n.bottom ||
    m.bottom < n.top
  )
}

roomIntersectsRoom :: StandardRoom a -> StandardRoom b -> Boolean
export roomIntersectsRoom = (a, b) => {
  m = getBoundingBox(a)
  n = getBoundingBox(b)
  return !(
    m.left   - 1 > n.right  ||
    m.right  + 1 < n.left   ||
    m.top    - 1 > n.bottom ||
    m.bottom + 1 < n.top
  )
}

doubleAndOne :: Integer -> Integer
doubleAndOne = (x) => 1 + x * 2

halfFloor :: Float -> Integer
halfFloor = (y) => floatToInteger(y / 2)

doubleRandomized :: Unusual -> Integer -> Integer
doubleRandomized = (u, x) => pipe(
  integerToFloat,
  halfFloor,
  u.int(0),
  doubleAndOne
)(x)

maxStageProp :: (RecordSeededConfig -> Integer) -> RecordSeededConfig -> Integer -> Integer
export maxStageProp = (fn, conf, x) => bound(1, fn(conf) - 4, x)

maxStageWidth :: RecordSeededConfig -> Integer -> Integer
maxStageWidth = maxStageProp(.width) 

maxStageHeight :: RecordSeededConfig -> Integer -> Integer
maxStageHeight = maxStageProp(.height) 

makeRoom :: Unusual -> RecordSeededConfig -> Integer -> StandardRoom String
export makeRoom = (u, conf, attempt) => {
  maxW = maxStageWidth(conf) 
  maxH = maxStageHeight(conf) 
  size = doubleAndOne(u.int(1, conf.roomSizeModifier))
  rectangularity = u.int(0, doubleAndOne(halfFloor(integerToFloat(size))))
  widthOrHeight = u.fate(2)
  rectSize = size + rectangularity
  w = maxW( !widthOrHeight ? rectSize : size)
  h = maxH( widthOrHeight ? rectSize : size )
  w2 = (conf.width - w)
  h2 = (conf.height - h)
  initialX = doubleRandomized(u, w2)
  initialY = doubleRandomized(u, h2)
  // deal with overlaps
  x = initialX + w > conf.width  ?
      max( 1, w - conf.width - 1 ) :
      initialX 
  y = initialY + h > conf.height ?
      max( 1, h - conf.height - 1 ) :
      initialY
  room = Room(#[x, y], w2, h2, "obsidian")
  return room
}

makeRooms :: RecordSeededConfig -> DungeonRooms String
export makeRooms = (conf) => {
  u = makeTwister(conf.seed)
  return pipe(
    .roomAttempts,
    range(0),
    reduce((prev, attempt) => {
      room = makeRoom(u, conf, attempt) 
      return pipe(
        find(roomIntersectsRoom(room)),
        where {
          Just(_) => prev
          Nothing => append(room, prev)
        }
      )(prev)
    }, [])
  )(conf)
}
