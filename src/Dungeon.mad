import IO from "IO"
import { filter, append, length, reduce, find, nth, mapWithIndex, range} from "List"
import {join, lastChar} from "String"
import type {Maybe} from "Maybe"
import {Just, Nothing} from "Maybe"
import {identity, ifElse, equals, when, always} from "Function"
import {formatDecimal, floatToInteger, integerToFloat} from "Number"

import type {
   RecordConfig, RecordSeededConfig
} from "@/Config"


import {abs, min, max, floor} from "@/Math"

import type { StandardRoom, DungeonRooms, StandardRoom } from "@/Room"
import {Room, makeRooms, roomIntersectsRoom, roomContainsPosition} from "@/Room"

import type { Position, DungeonTiles, Tile, CartesianTile, TileNeighbors } from "@/Tile"
import {Door, Wall, Hazard, Floor, InvalidTile} from "@/Tile"

import {Vector} from "@/Vector"

import type {Unusual} from "@/Unusual"
import {makeTwister} from "@/Unusual"

export alias RecordDungeon r t = {
  rooms :: DungeonRooms r,
  tiles :: DungeonTiles t
}

export type Dungeon width height rooms tiles = Dungeon(width, height, rooms, tiles)

makeDungeonWithConfig :: RecordSeededConfig
  -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
makeDungeonWithConfig = (conf) => {
  seed = conf.seed
  u = makeTwister(seed)
  width = conf.width
  height = conf.height
  roomAttempts = conf.roomAttempts
  roomConnectorChance = conf.roomConnectorChance
  roomSizeModifier = conf.roomSizeModifier
  walkWinding = conf.walkWinding
  directions = [
    Vector( -1,  0 ),
    Vector(  0,  1 ),
    Vector(  0, -1 ),
    Vector(  1,  0 )
  ]
  impassable = pipe(
    range(0),
    (xs) => pipe(
      range(0),
      (ys) => chain(
        (x) => map(
          (y) => Wall(#[x, y], "carbon")
        )(ys)
      )(xs)
    )(height)
  )(width)
  /*
  neighbors = (
    (i) => map(map(
      where {
        Wall(x, y, raw) => getNeighborsFromTiles(i, x, y)
      }
    ))(i)
  )(impassable)
  */
  rooms = makeRooms(u, conf)
  /*
  filteredTiles = map(
    (room) => chain(filter(
      where {
        Wall(x, y, _) => roomContainsPosition(room, x, y)
      }
    ))(impassable)
  )(rooms)
  IO.trace("TILES", {filteredTiles, tiles:impassable})
  */
  /*
  hsize = pipe(
    nth(0),
    where {
      Just(x) => length(x)
      Nothing => 0
    }
  )(impassable)
  IO.trace(`totes wide? ${toString(width)}`, length(impassable))
  IO.trace(`totes tall? ${toString(height)}`, hsize)
  IO.trace(`uhhhh`, length(impassable) * hsize)
  */
  state = {rooms, region: -1, tiles: impassable}
  return Dungeon(
    width,
    height,
    state.rooms,
    state.tiles
  )
}

defaultConfig :: RecordConfig
export defaultConfig = {
  width: 5,
  height: 5,
  roomAttempts: 50,
  roomConnectorChance: 50,
  roomSizeModifier: 1,
  walkWinding: 1 / 2
}

makeDungeonFromSeed :: String -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
export makeDungeonFromSeed = (seed) => makeDungeonWithConfig({
  width: 15,
  height: 15,
  roomAttempts: 50,
  roomConnectorChance: 50.0,
  roomSizeModifier: 1,
  walkWinding: 1 / 2,
  seed: seed
})

roomSection :: StandardRoom String -> Integer -> String
roomSection = (room, y) => pipe(
  where {
    Room(_, w, h, _) => pipe(
      ifElse(
        equals(y),
        pipe(
          range(0),
          map((_) => "*"),
          join("")
        ),
        always("")
      )
    )(w)
  }
)(room)

toString :: x -> String
toString = (x) => #- "" + x -#

lastDigitAsString :: Integer -> String
lastDigitAsString = pipe(
  toString,
  lastChar,
  where {
    Just(c) => toString(c)
    Nothing => "?"
  }
)

// renderDungeon :: Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String) -> String
export renderDungeon = (dungeon) => pipe(
  where {
    Dungeon(w, h, rooms, tiles) => map(
      (room) => map(
        where {
          Wall(pos, _) => roomContainsPosition(room, pos) ?
            " " :
            where (pos) {
              #[x, y] => (
                y == 0 ?
                lastDigitAsString(x) :
                y == h - 1 ?
                "#\n" :
                "#"
              )
            }
        }
      )(tiles)
    )(rooms)
  },
  map(join("")),
  join("")
)(dungeon)
