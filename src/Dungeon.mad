import IO from "IO"
import { filter, append, length, reduce, find, nth, mapWithIndex, range} from "List"
import {join, lastChar} from "String"
import type {Maybe} from "Maybe"
import {Just, Nothing} from "Maybe"
import {identity, ifElse, equals, when, always} from "Function"
import {formatDecimal, floatToInteger, integerToFloat} from "Number"

import type {RecordSeededConfig, RecordConfig} from "@/Config"
import {drill} from "@/IO"
import {abs, min, max, floor} from "@/Math"

import type { StandardRoom, DungeonRooms, StandardRoom } from "@/Room"
import {Room, makeRooms, roomIntersectsRoom, roomContainsPosition} from "@/Room"

import {toString} from "@/String"

import type { Position, DungeonTiles, Tile, CartesianTile, TileNeighbors } from "@/Tile"
import {transformTile, Door, Wall, Hazard, Floor, InvalidTile} from "@/Tile"

import type {Unusual} from "@/Unusual"
import {makeTwister} from "@/Unusual"

import {Vector} from "@/Vector"


export type Dungeon width height rooms tiles = Dungeon(width, height, rooms, tiles)

// growMaze :: DungeonRooms String -> DungeonTiles String
//          -> #[DungeonRooms String, DungeonTiles String]
// growMaze = (rooms, tiles) => pipe(
//   map(pipe(
//     coord,
//     (pos) => where (pos) {
//       #[x, y] => 
//     }
//   ))
// )(tiles)

// getNeighborMap :: DungeonTiles String -> List BoundingBox
// getNeighborMap = map((tile) => getNeighborsFromTiles
// )

makeDungeonWithConfig :: RecordSeededConfig
                      -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
makeDungeonWithConfig = (conf) => {
  seed = conf.seed
  u = makeTwister(seed)
  width = conf.width
  height = conf.height
  roomAttempts = conf.roomAttempts
  roomConnectorChance = conf.roomConnectorChance
  roomSizeModifier = conf.roomSizeModifier
  walkWinding = conf.walkWinding
  directions = [
    Vector( -1,  0 ),
    Vector(  0,  1 ),
    Vector(  0, -1 ),
    Vector(  1,  0 )
  ]
  gestalt = pipe(
    range(0),
    (xs) => pipe(
      range(0),
      (ys) => chain(
        (x) => map(
          (y) => Wall(#[x, y], "carbon")
        )(ys)
      )(xs)
    )(height)
  )(width)
  /*
  neighbors = (
    (i) => map(map(
      where {
        Wall(x, y, raw) => getNeighborsFromTiles(i, x, y)
      }
    ))(i)
  )(gestalt)
  */
  rooms = makeRooms(conf)
  // tiles = growMaze(rooms, gestalt)
  
  IO.trace("how many tiles?", length(gestalt))
  drill("how many tiles inspectory?", length, gestalt)
  state = {rooms, region: -1, tiles: gestalt}
  return Dungeon(
    width,
    height,
    state.rooms,
    state.tiles
  )
}

defaultConfig :: RecordSeededConfig
export defaultConfig = {
  seed: "default config",
  width: 50,
  height: 50,
  roomAttempts: 4000,
  roomConnectorChance: 50.0,
  roomSizeModifier: 46,
  walkWinding: 1 / 2
}

makeDungeonFromSeed :: String -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
export makeDungeonFromSeed = (seed) => makeDungeonWithConfig({...defaultConfig, seed})

roomSection :: StandardRoom String -> Integer -> String
roomSection = (room, y) => pipe(
  where {
    Room(_, w, h, _) => pipe(
      ifElse(
        equals(y),
        pipe(
          range(0),
          map((_) => "*"),
          join("")
        ),
        always("")
      )
    )(w)
  }
)(room)

lastDigitAsString :: Integer -> String
lastDigitAsString = pipe(
  toString,
  lastChar,
  where {
    Just(c) => toString(c)
    Nothing => "?"
  }
)

renderDungeon :: Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String) -> String
export renderDungeon = (dungeon) => (
  where (dungeon) {
    Dungeon(w, h, rooms, tiles) => pipe(
      map(
        transformTile(
          (pos, _) => (
            where (pos) {
              #[x, y] => pipe(
                find(roomContainsPosition($, pos)),
                (found) => (where (found) {
                  Just(_) => ` `
                  Nothing => `#`
                }),
                (b) => `${b}${y == h - 1 ? "\n" : ""}`
              )(rooms)
            }
          )
        )
      ),
      join("")
    )(tiles)
  }
)

/*
export renderDungeon = (dungeon) => pipe(
  where {
    Dungeon(w, h, rooms, tiles) => chain(
      (room) => map(
        where {
          Wall(pos, _) => pipe(
            where {
              #[x, y] => (
                roomContainsPosition(room, pos) ?
                  y == h - 1 ?
                    " \n" :
                    " " :
                  y == 0 ?
                    lastDigitAsString(x) :
                    y == h - 1 ?
                      "#\n" :
                      "#"
              )
            }
          )(pos)
        }
      )(tiles)
    )(rooms)
  },
  join("")
)(dungeon)
*/
