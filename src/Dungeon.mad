import IO from "IO"
import { length, find, range, reduce,  filter} from "List"
import {join, lastChar} from "String"
import {Just, Nothing} from "Maybe"
import {ifElse, equals, always, any, memoize} from "Function"
import {toList} from "Dictionary"
import {snd} from "Tuple"

import {either} from "@/Function"

import type {RecordSeededConfig } from "@/Config"
import {drill} from "@/IO"

import type { StandardRoom, DungeonRooms, StandardRoom } from "@/Room"
import {Room, makeRooms, roomContainsPosition} from "@/Room"

import {toString} from "@/String"

import type { DungeonTiles, Position } from "@/Tile"
import {transformTile, Wall, getNeighborsForPosition, coord } from "@/Tile"

import {makeTwister} from "@/Unusual"

import {Vector} from "@/Vector"


export type Dungeon width height rooms tiles = Dungeon(width, height, rooms, tiles)
export alias CartesianDungeon = Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)

memoGetNeighborsForPosition = memoize(getNeighborsForPosition)
memoRoomContainsPosition = memoize(roomContainsPosition)

neighborsInRooms :: DungeonRooms String -> DungeonTiles String -> Position -> Boolean
neighborsInRooms = (rooms, tiles, pos) => pipe(
  memoGetNeighborsForPosition(tiles),
  map((n) => any(
    memoRoomContainsPosition($, coord(n))
  )(rooms)),
  toList,
  reduce((a, b) => a && snd(b), true)
)(pos)

growMaze :: CartesianDungeon 
         -> Position
         -> CartesianDungeon
export growMaze = (dungeon, origin) => (where (origin) {
  #[xx, yy] => (
    where (dungeon) {
      Dungeon(w, h, rooms, tiles) => do {
        return pipe(
          map(transformTile(
            (pos, data) => (
              where (pos) {
                #[x, y] => do {
                  anyNeighborIsInRoom = neighborsInRooms(rooms, tiles, pos) 
                  return pipe(
                    find(
                      either(
                        roomContainsPosition($, pos),
                        always(anyNeighborIsInRoom)
                      )
                    ),
                    where {
                      Just(_) => true
                      Nothing => false
                    },
                    (inroom) => Wall(pos, data)
                  )(rooms)
                }
              }
            )
          )),
          (newTiles) => Dungeon(w, h, rooms, newTiles)
        )(tiles)
      }
    }
  )
})

makeDungeonWithConfig :: RecordSeededConfig -> CartesianDungeon
makeDungeonWithConfig = (conf) => {
  seed = conf.seed
  u = makeTwister(seed)
  width = conf.width
  height = conf.height
  roomAttempts = conf.roomAttempts
  roomConnectorChance = conf.roomConnectorChance
  roomSizeModifier = conf.roomSizeModifier
  walkWinding = conf.walkWinding
  directions = [
    Vector( -1,  0 ),
    Vector(  0,  1 ),
    Vector(  0, -1 ),
    Vector(  1,  0 )
  ]
  gestalt = pipe(
    range(0),
    (xs) => pipe(
      range(0),
      (ys) => chain(
        (x) => map(
          (y) => Wall(#[x, y], "carbon")
        )(ys)
      )(xs)
    )(height)
  )(width)
  /*
  neighbors = (
    (i) => map(map(
      where {
        Wall(x, y, raw) => getNeighborsFromTiles(i, x, y)
      }
    ))(i)
  )(gestalt)
  */
  rooms = makeRooms(conf)
  // tiles = growMaze(rooms, gestalt)
  // IO.trace("how many tiles?", length(gestalt))
  // drill("how many tiles inspectory?", length, gestalt)
  state = {rooms, region: -1, tiles: gestalt}
  return Dungeon(
    width,
    height,
    state.rooms,
    state.tiles
  )
}


defaultConfig :: RecordSeededConfig
export defaultConfig = {
  seed: "default config",
  width: 50,
  height: 50,
  roomAttempts: 100000,
  roomConnectorChance: 50.0,
  roomSizeModifier: 4000,
  walkWinding: 1 / 2
}

makeDungeonFromSeed :: String -> CartesianDungeon 
export makeDungeonFromSeed = (seed) => makeDungeonWithConfig({...defaultConfig, seed})

roomSection :: StandardRoom String -> Integer -> String
roomSection = (room, y) => pipe(
  where {
    Room(_, w, h, _) => pipe(
      ifElse(
        equals(y),
        pipe(
          range(0),
          map((_) => "*"),
          join("")
        ),
        always("")
      )
    )(w)
  }
)(room)

lastDigitAsString :: Integer -> String
lastDigitAsString = pipe(
  toString,
  lastChar,
  where {
    Just(c) => toString(c)
    Nothing => "?"
  }
)

export BLOCK_EDGE = "X"
export BLOCK_WALL = "#"
export BLOCK_ROOM = " "

renderDungeon :: CartesianDungeon -> String 
export renderDungeon = (dungeon) => (
  where (dungeon) {
    Dungeon(w, h, rooms, tiles) => pipe(
      map(
        transformTile(
          (pos, _) => (
            where (pos) {
              #[x, y] => pipe(
                find(roomContainsPosition($, pos)),
                (found) => (where (found) {
                  Just(_) => BLOCK_ROOM
                  Nothing => BLOCK_WALL
                }),
                (b) => `${y == 0 ? BLOCK_EDGE : ""}${b}${y == h - 1 ? BLOCK_EDGE ++ "\n" : ""}`
              )(rooms)
            }
          )
        )
      ),
      join(""),
      (meat) => pipe(
        range(0),
        map(always(BLOCK_EDGE)),
        join(""),
        (bread) => bread ++ "\n" ++ meat ++ bread
      )(w + 2)
    )(tiles)
  }
)

