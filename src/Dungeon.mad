import IO from "IO"
import { filter, append, reduce, find, nth, mapWithIndex, range} from "List"
import {join, lastChar} from "String"
import type {Maybe} from "Maybe"
import {Just, Nothing} from "Maybe"
import {identity, ifElse, equals, when, always} from "Function"
import {formatDecimal, floatToInteger, integerToFloat} from "Number"
import {abs,min, max, floor} from "./Math"

import type {
   DungeonRooms, StandardRoom,
   RecordDungeon, Dungeon, 
   DungeonTiles, Tile, CartesianTile,
   TileNeighbors,
   RecordConfig, RecordSeededConfig
} from "./Types"
import {Room, Door, Wall, Hazard, Floor, Dungeon, InvalidTile} from "./Types"
import {Vector} from "./Vector"
import type {Unusual} from "./Unusual"
import {makeTwister} from "./Unusual"
import {roomIntersectsRoom, roomContainsTile} from "./Maze"

tileAt :: Integer -> Integer -> DungeonTiles t -> Maybe (Maybe (CartesianTile t))
tileAt = (x, y, tiles) => pipe(
  nth(y),
  map(nth(x))
)(tiles)


getTileAt :: DungeonTiles t -> Integer -> Integer -> CartesianTile t
getTileAt = (tiles, x, y) => pipe(
  tileAt(x, y),
  where {
    Just(row) => (where {
      Just(t) => t
      Nothing => InvalidTile
    })(row)
    Nothing => InvalidTile
  }
)(tiles)

tileExists :: DungeonTiles t -> Integer -> Integer -> Boolean
export tileExists = (tiles, x, y) => pipe(
  getTileAt(tiles, x),
  where {
    Wall(_, _, _) => true
    Floor(_, _, _) => true
    Door(_, _, _) => true
    Hazard(_, _, _) => true
    InvalidTile => false
  }
)(y)

setTileAt :: DungeonTiles t -> Integer -> Integer -> CartesianTile t -> DungeonTiles t
export setTileAt = (tiles, x, y, replacement) => mapWithIndex(
  (t, i) => mapWithIndex(
    (u, j) => when(
      (_) => i == y && j == x,
      always(replacement),
      u
    ),
    t
  ),
  tiles
)

transformTile :: (x -> y -> data -> z) -> Tile x y data -> z
transformTile = (fn, tile) => (
  where {
    Wall(x, y, data) => fn(x, y, data)
    Floor(x, y, data) => fn(x, y, data)
    Door(x, y, data) => fn(x, y, data)
    Hazard(x, y, data) => fn(x, y, data)
  }
)(tile)

getNeighborsFromTiles :: DungeonTiles String -> Integer -> Integer -> List (List (TileNeighbors String))
getNeighborsFromTiles = (tiles, x, y) => {
  at = getTileAt(tiles)
  return map(map(
    transformTile(
      (_, _, _) => ({
        n:  at( x   ,  y - 1 ),
        ne: at( x + 1, y - 1 ),
        e:  at( x + 1, y     ),
        se: at( x + 1, y + 1 ),
        s:  at( x    , y + 1 ),
        sw: at( x - 1, y + 1 ),
        w:  at( x - 1, y     ),
        nw: at( x - 1, y - 1 )
      })
    )
  ))(tiles)
}

doubleAndOne :: Integer -> Integer
doubleAndOne = (x) => 1 + x * 2

remainder :: Float -> Float -> Float
remainder = (d, n) => {
  q = n / d
  p = q * n
  return n - p
}

halfFloor :: Float -> Integer
halfFloor = (y) => floatToInteger(y / 2)

makeRoom :: Unusual -> RecordSeededConfig -> Integer -> StandardRoom String
makeRoom = (u, conf, _) => {
  maxW = max(conf.width - 4)
  maxH = max(conf.height - 4)
  size = doubleAndOne(u.int(1, 3 + conf.roomSizeModifier))
  rectangularity = u.int(0, doubleAndOne(halfFloor(integerToFloat(size))))
  widthOrHeight = u.fate(2)
  rectSize = size + rectangularity
  w = maxW( !widthOrHeight ? rectSize : size )
  h = maxH(  widthOrHeight ? rectSize : size )
  w2 = abs(conf.width - w)
  h2 = abs(conf.height - h)
  initialX = pipe(
    integerToFloat,
    halfFloor,
    u.int(0),
    doubleAndOne
  )(w2)
  initialY = pipe(
    integerToFloat,
    halfFloor,
    u.int(0),
    doubleAndOne
  )(h2)
  // deal with overlaps
  x = initialX + w > conf.width  ? max(1, w - conf.width - 1 ) : initialX 
  y = initialY + h > conf.height ? max(1, h - conf.height - 1 ) : initialY
  room = Room(x, y, w2, h2, "obsidian")
  return room
}

makeRooms :: Unusual -> RecordSeededConfig -> DungeonRooms String
makeRooms = (u, conf) => pipe(
  .roomAttempts,
  range(0),
  reduce((prev, attempt) => {
    room = makeRoom(u, conf, attempt) 
    return pipe(
      find(roomIntersectsRoom(room)),
      where {
        Just(_) => prev
        Nothing => append(room, prev)
      }
    )(prev)
  }, [])
)(conf)

makeDungeonWithConfig :: RecordSeededConfig -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
makeDungeonWithConfig = (conf) => {

  // const {seed, width, height, roomAttempts, roomConnectorChance, roomSizeModifier, walkWinding} = conf
  seed = conf.seed
  u = makeTwister(seed)
  width = conf.width
  height = conf.height
  roomAttempts = conf.roomAttempts
  roomConnectorChance = conf.roomConnectorChance
  roomSizeModifier = conf.roomSizeModifier
  walkWinding = conf.walkWinding
  directions = [
    Vector( -1,  0 ),
    Vector(  0,  1 ),
    Vector(  0, -1 ),
    Vector(  1,  0 )
  ]
  impassable = pipe(
    range(0),
    (xs) => pipe(
      range(0),
      (ys) => map(
        (x) => map(
          (y) => Wall(x, y, "carbon")
        )(ys)
      )(xs)
    )(height)
  )(width)
  // neighbors = (
  //   (i) => map(map(
  //     where {
  //       Wall(x, y, raw) => getNeighborsFromTiles(i, x, y)
  //     }
  //   ))(i)
  // )(impassable)
  rooms = makeRooms(u, conf)
  filteredTiles = map(
    (room) => chain(filter(
      where {
        Wall(x, y, _) => roomContainsTile(room, x, y)
      }
    ))(impassable)
  )(rooms)
  IO.trace("TILES", {filteredTiles, tiles:impassable})
  state = {rooms, region: -1, tiles: filteredTiles}
  return Dungeon(
    width,
    height,
    state.rooms,
    state.tiles
  )
}

defaultConfig :: RecordConfig
export defaultConfig = {
  width: 5,
  height: 5,
  roomAttempts: 50,
  roomConnectorChance: 50,
  roomSizeModifier: 1,
  walkWinding: 1 / 2
}

makeDungeonFromSeed :: String -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
export makeDungeonFromSeed = (seed) => makeDungeonWithConfig({
  width: 15,
  height: 15,
  roomAttempts: 50,
  roomConnectorChance: 50.0,
  roomSizeModifier: 1,
  walkWinding: 1 / 2,
  seed: seed
})

// roomSection :: StandardRoom String -> Integer -> String
roomSection = (room, y) => pipe(
  where {
    Room(_, _, w, h, _) => pipe(
      ifElse(
        equals(y),
        pipe(
          range(0),
          map((_) => "*"),
          join("")
        ),
        always("")
      )
    )(w)
  }
)(room)

toString :: x -> String
toString = (x) => #- "" + x -#

renderDungeon :: Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String) -> String
export renderDungeon = (dungeon) => pipe(
  where {
    Dungeon(w, h, rooms, tiles) => pipe(
      range(0),
      (xs) => pipe(
        range(0),
        (ys) => map(
          (x) => pipe(
            chain(
              (y) => map(
                ifElse(
                  roomContainsTile($, x, y),
                  always(toString(x)),
                  /*always(pipe(
                    toString,
                    lastChar,
                    where {
                      Just(c) => toString(c)
                      Nothing => ""
                    }
                  )(x)) 
                  */
                  always("#")
                )
              )(rooms)
            ),
            join("")
          )(ys)
        )(xs),
        join("\n")
      )(h)
    )(w)
  }
)(dungeon)
