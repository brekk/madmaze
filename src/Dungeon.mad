import IO from "IO"
import { filter, append, length, reduce, find, nth, mapWithIndex, range} from "List"
import {join, lastChar} from "String"
import type {Maybe} from "Maybe"
import {Just, Nothing} from "Maybe"
import {identity, ifElse, equals, when, always} from "Function"
import {formatDecimal, floatToInteger, integerToFloat} from "Number"

import type {
   RecordConfig, RecordSeededConfig
} from "@/Config"


import {abs, min, max, floor} from "@/Math"

import type { StandardRoom, DungeonRooms, StandardRoom } from "@/Room"
import {Room, makeRooms, roomIntersectsRoom, roomContainsPosition} from "@/Room"

import {toString} from "@/String"

import type { Position, DungeonTiles, Tile, CartesianTile, TileNeighbors } from "@/Tile"
import {Door, Wall, Hazard, Floor, InvalidTile} from "@/Tile"

import {Vector} from "@/Vector"

import type {Unusual} from "@/Unusual"
import {makeTwister} from "@/Unusual"

export alias RecordDungeon r t = {
  rooms :: DungeonRooms r,
  tiles :: DungeonTiles t
}

export type Dungeon width height rooms tiles = Dungeon(width, height, rooms, tiles)

// growMaze :: DungeonRooms String -> DungeonTiles String
//          -> #[DungeonRooms String, DungeonTiles String]
// growMaze = (rooms, tiles) => pipe(
//   map(pipe(
//     coord,
//     (pos) => where (pos) {
//       #[x, y] => 
//     }
//   ))
// )(tiles)

// getNeighborMap :: DungeonTiles String -> List BoundingBox
// getNeighborMap = map((tile) => getNeighborsFromTiles
// )

makeDungeonWithConfig :: RecordSeededConfig
                      -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
makeDungeonWithConfig = (conf) => {
  seed = conf.seed
  u = makeTwister(seed)
  width = conf.width
  height = conf.height
  roomAttempts = conf.roomAttempts
  roomConnectorChance = conf.roomConnectorChance
  roomSizeModifier = conf.roomSizeModifier
  walkWinding = conf.walkWinding
  directions = [
    Vector( -1,  0 ),
    Vector(  0,  1 ),
    Vector(  0, -1 ),
    Vector(  1,  0 )
  ]
  gestalt = pipe(
    range(0),
    (xs) => pipe(
      range(0),
      (ys) => chain(
        (x) => map(
          (y) => Wall(#[x, y], "carbon")
        )(ys)
      )(xs)
    )(height)
  )(width)
  /*
  neighbors = (
    (i) => map(map(
      where {
        Wall(x, y, raw) => getNeighborsFromTiles(i, x, y)
      }
    ))(i)
  )(gestalt)
  */
  rooms = makeRooms(conf)
  // tiles = growMaze(rooms, gestalt)
  
  IO.trace("how many tiles?", length(gestalt))
  // peep("how many tiles inspectory?", length, gestalt)
  state = {rooms, region: -1, tiles: gestalt}
  return Dungeon(
    width,
    height,
    state.rooms,
    state.tiles
  )
}

defaultConfig :: RecordConfig
export defaultConfig = {
  width: 5,
  height: 5,
  roomAttempts: 50,
  roomConnectorChance: 50,
  roomSizeModifier: 1,
  walkWinding: 1 / 2
}

// makeSeedableDungeonDefault :: String -> RecordSeededConfig
// makeSeedableDungeonDefault = (seed) => ({...defaultConfig, seed})

makeDungeonFromSeed :: String -> Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String)
export makeDungeonFromSeed = (seed) => makeDungeonWithConfig({
  width: 15,
  height: 15,
  roomAttempts: 50,
  roomConnectorChance: 50.0,
  roomSizeModifier: 1,
  walkWinding: 1 / 2,
  seed: seed
})

roomSection :: StandardRoom String -> Integer -> String
roomSection = (room, y) => pipe(
  where {
    Room(_, w, h, _) => pipe(
      ifElse(
        equals(y),
        pipe(
          range(0),
          map((_) => "*"),
          join("")
        ),
        always("")
      )
    )(w)
  }
)(room)

lastDigitAsString :: Integer -> String
lastDigitAsString = pipe(
  toString,
  lastChar,
  where {
    Just(c) => toString(c)
    Nothing => "?"
  }
)

renderDungeon :: Dungeon Integer Integer (DungeonRooms String) (DungeonTiles String) -> String
export renderDungeon = (dungeon) => pipe(
  where {
    Dungeon(w, h, rooms, tiles) => chain(
      (room) => map(
        where {
          Wall(pos, _) => roomContainsPosition(room, pos) ?
            " " :
            where (pos) {
              #[x, y] => (
                y == 0 ?
                lastDigitAsString(x) :
                y == h - 1 ?
                "#\n" :
                "#"
              )
            }
        }
      )(tiles)
    )(rooms)
  },
  // map(join("")),
  join("")
)(dungeon)
