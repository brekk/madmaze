import type {Maybe} from "Maybe"
import IO from "IO"
import {Just, Nothing} from "Maybe"
import {mapWithIndex, nth, find} from "List"
import {always, when} from "Function"

export alias Position = #[Integer, Integer]

export type Tile pos data
  = Wall(pos, data)
  | Floor(pos, data)
  | Door(pos, data)
  | Hazard(pos, data)
  | InvalidTile

export alias CartesianTile a = Tile Position a

export alias DungeonTiles t = List (CartesianTile t)

export alias TileNeighbors a = {
  n  :: CartesianTile a,
  ne :: CartesianTile a,
  e  :: CartesianTile a,
  se :: CartesianTile a,
  s  :: CartesianTile a,
  sw :: CartesianTile a,
  w  :: CartesianTile a,
  nw :: CartesianTile a
}

coord :: Tile Position a -> Position
coord = pipe(
  where {
    Wall(pos, _) => pos 
    Floor(pos, _) => pos 
    Door(pos, _) => pos 
    Hazard(pos, _) => pos 
  }
)

whale = Wall(#[10,4], "buddy")
IO.log(coord(whale))

coordEquals :: Position -> Tile Position a -> Boolean
coordEquals = (pos, tile) => pipe(
  where {
    #[x, y] => pipe(
      coord,
      where {
        #[x2, y2] => x == x2 && y == y2
      }
    )(tile)
  }
)(pos)

tileAt :: Position -> DungeonTiles t -> Maybe (CartesianTile t)
tileAt = (pos, tiles) => find(
  coordEquals(pos) 
)(tiles)


getTileAt :: Position -> DungeonTiles t -> CartesianTile t
getTileAt = (pos, tiles) => pipe(
  tileAt(pos),
  where {
    Just(t) => t 
    Nothing => InvalidTile
  }
)(tiles)

/*
tileExists :: Position -> DungeonTiles t -> Boolean
export tileExists = (pos, tiles) => pipe(
  getTileAt($, tiles),
  where {
    Wall(_, _, _) => true
    Floor(_, _, _) => true
    Door(_, _, _) => true
    Hazard(_, _, _) => true
    InvalidTile => false
  }
)(pos)
*/

setTileAt :: DungeonTiles t -> Position -> CartesianTile t -> DungeonTiles t
export setTileAt = (tiles, pos, replacement) => map(
  when(
    coordEquals(pos),
    always(replacement)
  )
)(tiles)

transformTile :: (pos -> data -> z) -> Tile pos data -> z
transformTile = (fn, tile) => (
  where {
    Wall(pos, data) => fn(pos, data)
    Floor(pos, data) => fn(pos, data)
    Door(pos, data) => fn(pos, data)
    Hazard(pos, data) => fn(pos, data)
  }
)(tile)
/*
getNeighborsFromTiles :: DungeonTiles String -> Position -> List (List (TileNeighbors String))
getNeighborsFromTiles = (tiles, pos) => {
  at = getTileAt($, tiles)
  return (
    where (pos) {
      #[x, y] => map(
        transformTile(
          (_, _) => ({
          n:  at( #[ x   ,  y - 1 ] ),
          ne: at( #[ x + 1, y - 1 ] ),
          e:  at( #[ x + 1, y     ] ),
          se: at( #[ x + 1, y + 1 ] ),
          s:  at( #[ x    , y + 1 ] ),
          sw: at( #[ x - 1, y + 1 ] ),
          w:  at( #[ x - 1, y     ] ),
          nw: at( #[ x - 1, y - 1 ] )
        })
      )
    )(tiles)
    }
  )
}
*/

export alias BoundingBox = {
  top    :: Integer,
  right  :: Integer,
  bottom :: Integer,
  left   :: Integer
}
